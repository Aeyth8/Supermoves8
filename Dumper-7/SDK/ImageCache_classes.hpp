#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ImageCache

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class ImageCache.AsyncTaskFetchImage
// 0x0020 (0x0050 - 0x0030)
class UAsyncTaskFetchImage final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncTaskFetchImage* FetchImage(const class FString& URL);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskFetchImage">();
	}
	static class UAsyncTaskFetchImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskFetchImage>();
	}
};
static_assert(alignof(UAsyncTaskFetchImage) == 0x000008, "Wrong alignment on UAsyncTaskFetchImage");
static_assert(sizeof(UAsyncTaskFetchImage) == 0x000050, "Wrong size on UAsyncTaskFetchImage");
static_assert(offsetof(UAsyncTaskFetchImage, OnSuccess) == 0x000030, "Member 'UAsyncTaskFetchImage::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAsyncTaskFetchImage, OnFail) == 0x000040, "Member 'UAsyncTaskFetchImage::OnFail' has a wrong offset!");

// Class ImageCache.AsyncTaskQueueFetchImages
// 0x0098 (0x00C8 - 0x0030)
class UAsyncTaskQueueFetchImages final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnOneFinished;                                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAllFinished;                                     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x48];                                      // 0x0050(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlueprintAsyncActionBase*              CurrentFetchTask;                                  // 0x0098(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x28];                                      // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskQueueFetchImages* QueueFetchImages(const TArray<class FString>& Items, bool bClearMemory);

	void HandleFetchImageFail(const class FString& URL, class UTexture2DDynamic* Texture);
	void HandleFetchImageSucess(const class FString& URL, class UTexture2DDynamic* Texture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskQueueFetchImages">();
	}
	static class UAsyncTaskQueueFetchImages* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskQueueFetchImages>();
	}
};
static_assert(alignof(UAsyncTaskQueueFetchImages) == 0x000008, "Wrong alignment on UAsyncTaskQueueFetchImages");
static_assert(sizeof(UAsyncTaskQueueFetchImages) == 0x0000C8, "Wrong size on UAsyncTaskQueueFetchImages");
static_assert(offsetof(UAsyncTaskQueueFetchImages, OnOneFinished) == 0x000030, "Member 'UAsyncTaskQueueFetchImages::OnOneFinished' has a wrong offset!");
static_assert(offsetof(UAsyncTaskQueueFetchImages, OnAllFinished) == 0x000040, "Member 'UAsyncTaskQueueFetchImages::OnAllFinished' has a wrong offset!");
static_assert(offsetof(UAsyncTaskQueueFetchImages, CurrentFetchTask) == 0x000098, "Member 'UAsyncTaskQueueFetchImages::CurrentFetchTask' has a wrong offset!");

// Class ImageCache.ImageCache
// 0x0078 (0x00A0 - 0x0028)
class UImageCache final : public UObject
{
public:
	TMap<class FString, class UCacheItem*>        CacheMap;                                          // 0x0028(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x28];                                      // 0x0078(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageCache">();
	}
	static class UImageCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageCache>();
	}
};
static_assert(alignof(UImageCache) == 0x000008, "Wrong alignment on UImageCache");
static_assert(sizeof(UImageCache) == 0x0000A0, "Wrong size on UImageCache");
static_assert(offsetof(UImageCache, CacheMap) == 0x000028, "Member 'UImageCache::CacheMap' has a wrong offset!");

// Class ImageCache.CacheItem
// 0x0038 (0x0060 - 0x0028)
class UCacheItem : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CacheItem">();
	}
	static class UCacheItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCacheItem>();
	}
};
static_assert(alignof(UCacheItem) == 0x000008, "Wrong alignment on UCacheItem");
static_assert(sizeof(UCacheItem) == 0x000060, "Wrong size on UCacheItem");

// Class ImageCache.CacheBinaryItem
// 0x0010 (0x0070 - 0x0060)
class UCacheBinaryItem : public UCacheItem
{
public:
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CacheBinaryItem">();
	}
	static class UCacheBinaryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCacheBinaryItem>();
	}
};
static_assert(alignof(UCacheBinaryItem) == 0x000008, "Wrong alignment on UCacheBinaryItem");
static_assert(sizeof(UCacheBinaryItem) == 0x000070, "Wrong size on UCacheBinaryItem");

// Class ImageCache.CacheImageItem
// 0x0008 (0x0078 - 0x0070)
class UCacheImageItem final : public UCacheBinaryItem
{
public:
	class UTexture2DDynamic*                      Texture;                                           // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CacheImageItem">();
	}
	static class UCacheImageItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCacheImageItem>();
	}
};
static_assert(alignof(UCacheImageItem) == 0x000008, "Wrong alignment on UCacheImageItem");
static_assert(sizeof(UCacheImageItem) == 0x000078, "Wrong size on UCacheImageItem");
static_assert(offsetof(UCacheImageItem, Texture) == 0x000070, "Member 'UCacheImageItem::Texture' has a wrong offset!");

// Class ImageCache.ImageCacheLibrary
// 0x0000 (0x0028 - 0x0028)
class UImageCacheLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CacheImage(const class FString& URL);
	static void CacheImages(const TArray<class FString>& URLs);
	static void ClearAllImageCache();
	static void DeleteImageCache(const class FString& URL);
	static class UTexture2DDynamic* GetCachedImage(const class FString& URL);
	static class FString GetImageCacheDirectory();
	static int32 GetImageCacheExpireTime();
	static float GetImageCacheMaxSizeGB();
	static void SetImageCacheExpireTime(int32 ExpireTime);
	static void SetImageCacheMaxSizeGB(float SizeGB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageCacheLibrary">();
	}
	static class UImageCacheLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageCacheLibrary>();
	}
};
static_assert(alignof(UImageCacheLibrary) == 0x000008, "Wrong alignment on UImageCacheLibrary");
static_assert(sizeof(UImageCacheLibrary) == 0x000028, "Wrong size on UImageCacheLibrary");

// Class ImageCache.ImageCacheSettings
// 0x0018 (0x0040 - 0x0028)
class UImageCacheSettings final : public UObject
{
public:
	float                                         ImageCacheSizeGB;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ImageCacheExpireTime;                              // 0x002C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CacheFileDirectory;                                // 0x0030(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageCacheSettings">();
	}
	static class UImageCacheSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageCacheSettings>();
	}
};
static_assert(alignof(UImageCacheSettings) == 0x000008, "Wrong alignment on UImageCacheSettings");
static_assert(sizeof(UImageCacheSettings) == 0x000040, "Wrong size on UImageCacheSettings");
static_assert(offsetof(UImageCacheSettings, ImageCacheSizeGB) == 0x000028, "Member 'UImageCacheSettings::ImageCacheSizeGB' has a wrong offset!");
static_assert(offsetof(UImageCacheSettings, ImageCacheExpireTime) == 0x00002C, "Member 'UImageCacheSettings::ImageCacheExpireTime' has a wrong offset!");
static_assert(offsetof(UImageCacheSettings, CacheFileDirectory) == 0x000030, "Member 'UImageCacheSettings::CacheFileDirectory' has a wrong offset!");

}

